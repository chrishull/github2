/**
 * OC Standard Tiny Library
 * 
 * HttpProperties.cpp
 * Properties generated by a Form POST.  The meat of OC Agent's param passing.
 * 
 * Christopher Hull
 * www.opencountry.com
**/
#include <iostream>
#include <string>
#include <exception>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <pwd.h>
#include <netdb.h>
#include <stddef.h>
#include <dirent.h>

using namespace std;

#include "httpproperties.h"
#include "buffer.h"
#include "stringbuffer.h"
#include "lineiterrator.h"
#include "utils.h"

/**
    Given a pointer to a block of mem with header and content info,
    parse the data and generate a set of name value pairs based on
    the data submitted by a Form Post.
    @param char* Pointer to content
    @param int The size of the content.
*/
HttpProperties::HttpProperties(char* pContent, int size){

    m_IsPOSTData = false;
    this->AllowDuplicates();
    
    if (m_Debug) {
        StringBuffer*        pSB;
        pSB = new StringBuffer();
        pSB->Dump();
    }
    
    
    // Iterrate over the entier POST content (this includes headers)
    LineIterrator *pLineIterr = new LineIterrator(pContent, size);
    if (pLineIterr == NULL)
        return;
    
    // Get the first line.  This will say POST or GET
    // Only continue if it says POST
    char *pLine = pLineIterr->GetNext();
    if (  strcmp(pLine, "POST") != 0 ) {
        delete(pLineIterr);
        return;
    }
    
    m_IsPOSTData = true;
    
    // Get the last line in the buffer.  That will be the
    // line containing the Name Value pairs
    while (pLineIterr->IsLastLine() == false) {
        pLine = pLineIterr->GetNext();
    }
    if (pLine == NULL) {
        delete(pLineIterr);
        return;
    }
    
    // Decode the line into a second buffer
    char*   pDecodedLine = strdup(pLine);
    if (pDecodedLine == NULL) {
        delete(pLineIterr);
        return;
    }
    this->StrDecode( pDecodedLine, pLine );
    
    // Get rid of pLine and the iterrator that produced it
    // We only need pDecodedLine from now on
    delete(pLineIterr);
    
    // Now iterrate thru the content, recognizing the '&' character as our separator
    // We have a zero terminated line, so we can use strlen
    pLineIterr = new LineIterrator(pDecodedLine, strlen(pDecodedLine) );
    if (pLineIterr == NULL) {
        free(pDecodedLine);
        return;
    }
    pLineIterr->UseAmp();       // Count '&' as EOL
    pLine = pLineIterr->GetNext();
    while (pLine != NULL) {
        ((Properties *)this)->AddString(pLine);
        pLine = pLineIterr->GetNext();
    }

    // Get rid of pLine and the iterrator that produced it
    free(pDecodedLine);
}
HttpProperties::~HttpProperties(){}

/**
    Return the total number of properties stored in this object
*/
int HttpProperties::Size(){
    return ((Properties *)this)->Size();
}

/**
    Return the value associated with the given key.
*/
char* HttpProperties::Get(char* pKey){
    return ((Properties *)this)->Get(pKey);
}

/**
    Return the next name in the list.
*/
char* HttpProperties::GetNextName(){
    return ((Properties *)this)->GetNextName();
}

/**
    Return true if this HttpProperties object was built by valid
    data from a POST request.
*/
bool HttpProperties::IsPostData(){
    return m_IsPOSTData;
}


/**
    Convert a URL Encoded string to a normal string
    @param char* Space to store the result string.  Will be smaller then the
    given string.
    @param char* The URL Encoded string.
*/
void HttpProperties::StrDecode( char* pTo, char* pFrom) {
    
    for ( ; *pFrom != '\0'; ++pTo, ++pFrom ) {
        if ( pFrom[0] == '%' && isxdigit( pFrom[1] ) && isxdigit( pFrom[2] ) ) {
            *pTo = this->HexcodeToInt( pFrom[1] ) * 16 + this->HexcodeToInt( pFrom[2] );
            pFrom += 2;
	    } else
	        *pTo = *pFrom;
	}
	*pTo = '\0';
}
/**
    Given a hex representation in ascii, return the int it represents.
    (How many times have we all written this one)
*/
int HttpProperties::HexcodeToInt( char c ) {
    if ( c >= '0' && c <= '9' )
	    return c - '0';
    if ( c >= 'a' && c <= 'f' )
	    return c - 'a' + 10;
    if ( c >= 'A' && c <= 'F' )
	    return c - 'A' + 10;
    return 0;
}
  
  
/**
    Tell GetNextName to automatically skip certain names by adding to 
    this list
    @param char* Neme to skip
*/
int HttpProperties::Skip(char* pSkip) {
    return ((Properties*)this)->Skip(pSkip);
}



